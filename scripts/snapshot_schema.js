const { Client } = require('pg');
const fs = require('fs');

const connectionString = process.argv[2];
const outputFile = process.argv[3] || 'production_schema_snapshot.sql';

if (!connectionString) process.exit(1);

const client = new Client({ connectionString });

async function run() {
    try {
        await client.connect();

        console.log("üì∏ Generating Ordered Schema Snapshot...");
        let sql = "-- PRODUCTION SCHEMA SNAPSHOT\n-- Generated by Antigravity\n\n";

        // 1. EXTENSIONS
        sql += "-- EXTENSIONS\n";
        const exts = await client.query('SELECT extname FROM pg_extension WHERE extname != \'plpgsql\'');
        exts.rows.forEach(r => {
            sql += `CREATE EXTENSION IF NOT EXISTS "${r.extname}";\n`;
        });
        sql += "\n";

        // 2. TABLES (Structure Only)
        sql += "-- TABLES\n";
        const getColumns = async (tableName) => {
            const res = await client.query(`
                SELECT column_name, data_type, is_nullable, column_default 
                FROM information_schema.columns 
                WHERE table_schema = 'public' AND table_name = $1
                ORDER BY ordinal_position
            `, [tableName]);

            return res.rows.map(c => {
                let def = c.column_default ? ` DEFAULT ${c.column_default}` : '';
                let nullb = c.is_nullable === 'YES' ? 'NULL' : 'NOT NULL';
                return `    "${c.column_name}" ${c.data_type}${def} ${nullb}`;
            }).join(",\n");
        };

        const tables = await client.query(`SELECT tablename FROM pg_tables WHERE schemaname = 'public'`);

        for (const t of tables.rows) {
            const name = t.tablename;
            sql += `CREATE TABLE IF NOT EXISTS "${name}" (\n`;
            sql += await getColumns(name);
            sql += "\n);\n";
            sql += `ALTER TABLE "${name}" ENABLE ROW LEVEL SECURITY;\n\n`;
        }

        // 3. FUNCTIONS
        sql += "-- FUNCTIONS\n";
        const funcs = await client.query(`
            SELECT pg_get_functiondef(f.oid) as def
            FROM pg_catalog.pg_proc f
            INNER JOIN pg_catalog.pg_namespace n ON (f.pronamespace = n.oid)
            WHERE n.nspname = 'public'
        `);
        funcs.rows.forEach(r => {
            sql += `${r.def};\n\n`;
        });

        // 4. TRIGGERS
        sql += "-- TRIGGERS\n";
        for (const t of tables.rows) {
            const triggers = await client.query(`
                SELECT pg_get_triggerdef(oid) as def
                FROM pg_trigger
                WHERE tgrelid = '"${t.tablename}"'::regclass
                AND tgisinternal = false
            `);
            triggers.rows.forEach(tr => {
                sql += `${tr.def};\n`;
            });
        }
        sql += "\n";

        // 5. RLS POLICIES
        sql += "-- RLS POLICIES\n";
        const policies = await client.query(`
            SELECT tablename, policyname, cmd, roles, qual, with_check
            FROM pg_policies WHERE schemaname = 'public'
        `);

        for (const p of policies.rows) {
            let roles = "PUBLIC";
            if (Array.isArray(p.roles)) {
                roles = p.roles.join(', ');
            } else if (typeof p.roles === 'string') {
                roles = p.roles.replace(/[{}]/g, '').split(',').join(', ');
            }

            let using = p.qual ? `USING (${p.qual})` : '';
            let check = p.with_check ? `WITH CHECK (${p.with_check})` : '';

            sql += `DROP POLICY IF EXISTS "${p.policyname}" ON "${p.tablename}";\n`;
            sql += `CREATE POLICY "${p.policyname}" ON "${p.tablename}"\n`;
            sql += `FOR ${p.cmd}\nTO ${roles}\n${using}\n${check};\n\n`;
        }

        // 6. CONSTRAINTS (PKs, FKs, Unique)
        sql += "-- CONSTRAINTS\\n";
        // We can fetch constraints via pg_get_constraintdef
        const constraints = await client.query(`
            SELECT 
                conrelid::regclass::text as tablename, 
                conname, 
                pg_get_constraintdef(oid) as def
            FROM pg_constraint
            WHERE connamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public')
            ORDER BY contype DESC -- 'p' (primary key) first usually
        `);

        for (const c of constraints.rows) {
            sql += `ALTER TABLE "${c.tablename}" DROP CONSTRAINT IF EXISTS "${c.conname}";\\n`;
            sql += `ALTER TABLE "${c.tablename}" ADD CONSTRAINT "${c.conname}" ${c.def};\\n\\n`;
        }

        fs.writeFileSync(outputFile, sql);
        console.log(`‚úÖ Ordered Snapshot with Constraints saved to ${outputFile}`);

    } catch (err) {
        console.error("‚ùå FAILED:", err);
    } finally {
        await client.end();
    }
}

run();
